# 서버 기초와 API 설계

## 서버의 개념과 역할

서버는 네트워크를 통해 클라이언트로부터 요청을 받아 처리하고 그에 따른 결과를 클라이언트에게 제공하는 컴퓨터 시스템

데이터를 저장하고 관리하며 클라이언트가 필요로하는 서비스나 데이터를 제공

### 주요 역할

- 데이터 제공
- 서비스 제공
- 자원 관리
- 네트워크 통신 관리

### 서버 종류

- 웹 서버: HTTP 프로토콜을 사용하여 웹페이지를 제공하는 서버 (Apache, Nginx, React 등)
- 데이터베이스 서버: DBMS를 통해 데이터 저장과 관리를 담당하는 서버 (MySQL, PostgreSQL 등)
- 애플리케이션 서버: 비즈니스 로직을 실행하고 데이터 처리를 수행하는 서버(Tomcat, JBoss, Node.JS, Java Spring 등)
- 파일 서버: 파일을 저장하고 다른 사람과 공유할 수 있는 서버
- 메일 서버: 이메일 송수신을 관리하는 서버

### 웹 서버의 구성 요소

- 웹 서버 소프트웨어: Apache 등 클라이언트 요청을 처리하는 소프트웨어
- 애플리케이션 서버: 동적 컨텐츠 생성을 위해 서버사이드 스크립트를 실행하는 환경
- 데이터베이스 서버: 데이터를 저장하고 관리하는 시스템, 웹 서버는 데이터베이스와 상호작용하여 클라이언트 요청에 필요한 데이터를 가져옴
- 파일 시스템: 웹 서버는 파일 시스템을 통해 정적 컨텐츠를 클라이언트에게 제공하며 로그 파일과 설정 파일 등을 저장

<img width="696" alt="image" src="https://github.com/user-attachments/assets/6d153b87-c58d-454b-b208-89aa08e9d25f">

### 서버 가용성과 성능

- 서버 가용성
    - 정의: 서버가 정상적으로 운영되고 사용자 요청에 응답할 수 있는 능력
    - 목표: 최대한의 업타임을 유지하여 사용자가 언제든 서비스에 접근할 수 있도록 하는 것
- 서버 성능
    - 정의: 서버가 요청을 처리하는 속도와 효율성을 의미
    - 목표: 요청에 대한 신속하고 일관된 응답을 제공하는 것
- 두 요소는 균형을 이뤄야하고 상호 보완적인 개념임.

### 서버 상태를 나타내는 지표

- CPU 사용률
- 메모리 사용률
- 디스크 I/O
- 네트워크 대역폭
- 응답 시간
- 트랜잭션 처리율
- 에러율
- 업타임
- 다운타임

### 서버 상태 모니터링 방법

- 모니터링 도구 활용
    - Prometheus & Grafana
        - Prometheus: 시계열 데이터베이스로 서버 성능 지표를 수집하고 저장
        - Grafana: 시각화 도구로 Prometheus 데이터를 기반으로 대시보드 작성
    - Nagios: 서버, 네트워크 앱 모니터링을 위한 오픈소스 도구
    - Zabbix: 서버와 네트워크 장비 모니터링을 위한 오픈소스 플랫폼
    - New Relic: 앱 성능 모니터링 도구로 서버 성능과 앱 상태를 모니터링
- 로그 분석
    - ELK Stack(Elasticsearch, Logstash, Kibana)
        - Elasticsearch: 로그 데이터를 저장하고 검색
        - Logstash: 로그 데이터를 수집하고 변환
        - Kibana: 로그 데이터를 시각화
    - Graylog: 실시간 로그 관리 분석 도구
- 시스템 내장 도구 사용
    - top/htop: 실시간으로 CPU, 메모리 사용량, 프로세스 상태 모니터링
    - vmstat: 시스템 성능과 관련된 다양한 메트릭 제공
    - iostat: 디스크 I/O와 CPU 사용량 모니터링
    - netstat: 네트워크 연결 상태와 통계 정보 제공

## 다양한 통신 프로토콜

통신 프로토콜은 네트워크에서 데이터를 주고받기 위한 규칙과 절차의 집합

### 주요 기능

- 데이터 포맷 지정
- 전송 절차(흐름) 규정
- 에러 검출 및 수정
- 송신자와 수신자 간 동기화
- 데이터 압축

### 프로토콜 예시

### HTTP/HTTPS

- HTTP
    - 웹 브라우저와 서버 간 데이터 전송에 사용
    - 클라이언트가 서버에 요청을 보내고 서버가 응답을 반환
    - 주로 웹 페이지, 이미지, 동영상 등의 리소스를 클라이언트에게 전달
    - HTTP 메소드 활용
- HTTPS
    - HTTP의 보안 버전으로 데이터 전송 시 TLS(Transport Layer Security) 또는 SSL(Secure Socket Layer) 프로토콜을 사용하여 암호화
    - 데이터 무결성, 기밀성, 인증을 보장하여 중간에서 데이터를 가로채거나 변조하는 것을 방지
- HTTP/HTTPS: SSL/TLS
    - SSL은 인터넷 통신의 보안을 위해 개발된 프로토콜
    - TLS는 SSL의 후속 프로토콜로 보안성과 효율성을 개선한 버전
    - 작동 방식
        - 핸드셰이크 과정
            - 클라이언트 헬로: 클라이언트가 서버에 연결 요청을 보내며 지원하는 암호화 알고리즘 목록을 전송
            - 서버 헬로: 서버가 클라이언트의 요청에 응답하며 사용할 암호화 알고리즘을 선택하고 서버 인증서를 전송
            - 키 교환: 클라이언트와 서버가 세션 키를 생성하기 위한 정보를 교환
            - 세션 키 생성: 클라이언트와 서버는 교환한 정보를 바탕으로 동일한 세션 키 생성
        - 암호화된 통신: 핸드 셰이크가 완료된 후 클라이언트와 서버 간 모든 데이터는 세션 키를 사용하여 암호화됨
        
        <img width="618" alt="image" src="https://github.com/user-attachments/assets/9add2367-30a5-4e0f-b592-13ea46dfcdd7">

        
- HTTP/HTTPS: 요청 구조
    1. 요청 라인
        - 메소드: HTTP 요청의 종류를 나타냄
        - URL: 요청 대상 리소스의 경로
        - HTTP 버전: 사용되는 HTTP 프로토콜의 버전
        
        <img width="618" alt="image" src="https://github.com/user-attachments/assets/9cf04740-0217-4190-8516-7fc5df731a68">

        
    2. 헤더(Headers)
        - 요청에 대한 메타 데이터 포함
        - 각 헤더는 이름:값 형식으로 작성
        - 자주 사용되는 요청 헤더
            - Host: 요청되는 호스트의 도메인 이름과 포트 번호
            - User-Agent: 요청을 보낸 클라이언트의 소프트웨어 정보
            - Content-type: 요청 본문의 데이터 타입을 지정
            - Authorization: 인증 토큰이나 자격 증명 포함
    3. 바디
        - 요청에 대한 데이터 포함
        - GET 요청에는 바디가 없으며 POST, PUT 요청에서 주로 사용
        - 예시: 폼 데이터, JSON, XML 등
- HTTP/HTTPS: 응답 구조
    1. 상태 라인
        - HTTP 버전: 사용되는 HTTP 프로토콜의 버전
        - 상태 코드: 요청에 대한 서버의 응답 상태
        - 상태 메시지: 상태 코드에 대한 설명(OK, Not Found, Internal Server Error 등)
        
        <img width="618" alt="image" src="https://github.com/user-attachments/assets/ef53b848-1761-4a6c-b339-717b9fdaee44">

        
    2. 헤더
        - 응답에 대한 메타데이터 포함
        - 각 헤더는 이름: 값 형식으로 작성
        - 자주 사용되는 응답 헤더
            - Content-Type: 응답 본문의 데이터 타입 지정
            - Content-Length: 응답 본문의 길이를 바이트 단위로 지정
            - Set-Cookie: 서버가 클라이언트에게 설정할 쿠키를 지정
    3. 바디
        - 응답에 대한 데이터 포함
        - 웹 페이지 HTML, JSON, 이미지 등 다양한 형태로 전송 가능

### WebSocket

- TCP기반의 실시간 양방향 통신을 제송하는 컴퓨터 통신 프로토콜
- 웹 앰과 웹 서버 간의 지속적인 연결을 가능하게 하여 실시간 데이터 전송이 필요한 앱에 적합
- 통신 과정
    - Handshake: 클라이언트가 서버에 WebSocket 연결을 요청하고 서버가 요청을 수락하여 WebSocket 연결을 설정
    - 양방향 데이터 전송: 연결이 설정된 후에는 클라이언트와 서버 간 양방향으로 데이터 전송 가능
    - 연결 유지: 연결이 설정된 후에는 지속적으로 데이터를 주고받을 수 있어 실시간 게임, 채팅 등에 적합
- WebSocket은 SSL/TLS를 통해 암호화할 수 있어 보안이 강화될 수 있음

### FTP

- 파일을 네트워크를 통해 전송하기 위한 표준 프로토콜
- FTP 모드
    - 액티브 모드
        - 클라이언트가 서버의 포트 21에 연결 시작
        - 클라이언트는 데이터 전송을 위해 자신의 임의 포트를 서버에 알림
        - 서버는 클라이언트가 알린 포트로 데이터 연결을 시도
        - 장점: 설정이 간단하고, NAT 이전 네트워크에서 주로 사용
        - 단점: 클라이언트의 방화벽이 서버의 연결 요청을 막을 수 있음
    - 패시브 모드
        - 클라이언트가 서버의 포트 21에 연결을 시작
        - 서버는 데이터 전송을 위해 자신의 임의의 포트를 클라이언트에 알림
        - 클라이언트는 서버가 알린 포트로 데이터 연결 시도
        - 장점: 클라이언트의 방화벽 문제를 피할 수 있음
        - 단점: 서버의 방화벽 설정이 필요할 수 있음.

### SSH

- 원격 서버에 안전하게 접속하기 위한 프로토콜
- 주로 터미널 세션에서 보안된 방식으로 명령을 실행하거나 파일을 전송하는데 사용
- 통신 과정
    - 인증: 클라이언트가 서버에 접속 요청을 보내면 서버는 클라이언트의 신원을 확인
    - 암호화된 세션: 접속이 승인되면 클라이언트와 서버 간 데이터 전송은 암호화된 채널을 통해 이뤄짐
    - 명령 실행: SSH 세션을 통해 원격 서버에서 명령을 실행하거나 파일 전송 가능
- 데이터 전송 과정에서 암호화를 사용하여 보안 강화

## 요청 플로우와 데이터 전달 구조

### 일반적인 클라이언트 요청과 서버 응답 플로우

1. 클라이언트: 사용자 인터페이스를 통해 요청을 생성하고 서버로 전송
2. 컨트롤러 
    - 클라이언트의 요청을 받아 처리
    - 필요한 데이터를 서비스로 전달하고 서비스에서 반환된 데이터를 클라이언트에 전달
3. 서비스
    - 비즈니스 로직 처리
    - 데이터베이스와의 상호작용, 데이터 처리와 관련된 모든 작업 수행
4. 모델
    - 데이터의 구조를 정의하고 데이터베이스에서 읽거나 저장할 때 사용하는 객체
    - 데이터의 유효성 검사 포함 가능

<img width="676" alt="image" src="https://github.com/user-attachments/assets/0bc1ff78-ab91-4d62-8e76-bb216b9144a5">

<img width="718" alt="image" src="https://github.com/user-attachments/assets/9fea0993-82f3-4598-8ea1-c415ee2b4b56">

<img width="478" alt="image" src="https://github.com/user-attachments/assets/3bc50b04-185e-404a-ae64-f3f404069d6f">

### 데이터 전달 구조

<img width="696" alt="image" src="https://github.com/user-attachments/assets/15239107-b27a-4cf0-9580-df7e85e07e4a">

### DTO(Data Transfer Object)

클라이언트와 서버 간 데이터 교환을 위한 객체

주로 데이터 전송에 필요한 필드와 메서드를 포함하며 데이터 전송의 효율성과 보안을 고려하여 설계

DTO는 클라이언트가 전송한 데이터를 서버에서 사용할 수 있도록 변환하거나 서버가 클라이언트에게 응답할 데이터를 구성하는 데 사용

데이터 전송의 효율성과 일관성을 유지하는데 이점

- DTO 예시

```jsx
//사용자 정보에 대한 DTO 정의
class UserDTO{
	constructor(id, username, email){
		this.id=id;
		this.username=username;
		this.email=email;
	}
}

//서버에서 클라이언트로 전송할 때 사용되는 DTO 객체 생성
const userDTO = new UserDTO(1, "john_doe", "john_doe@example.com");

//클라이언트에서 서버로 전송할 때 사용되는 DTO 객체 생성
const updateUserDTO = new UserDTO(1, "john_doe", "john_doe@example.com");
```

### Entity와 Schema

데이터베이스에 저장되는 데이터를 표현하는 객체

주로 데이터베이스의 테이블의 구조와 일치하며 데이터베이스의 각 행을 객체로 표현

서버에서 데이터를 처리할 때 데이터의 유효성을 검증하거나 데이터의 구조적 변경을 반영하는데 활용

Schema는 데이터베이스 자료구조를 정의하는 개념이고 Entity는 소프트웨어에서 데이터 모델을 표현하는 객체

따라서 어떤 이름을 사용해도 큰 문제는 없지만 일반적으로 ORM을 사용할 경우 ORM에 맞추어 파일명을 작성한은 것이 좋음

<img width="696" alt="image" src="https://github.com/user-attachments/assets/1475c144-fe3c-4878-b8ee-3d9ae0cdccfb">

## API 엔드포인트 설계

<img width="698" alt="image" src="https://github.com/user-attachments/assets/ca26a3e8-0a26-4875-bda5-99c6aa1755b5">

API 엔드포인트는 클라이언트가 서버의 리소스에 접근하기 위한 URL

클라이언트와 서버 간 통신 인터페이스를 제공하는 역할

API 엔드포인트를 설계한다는 것은 클라이언트와 어떤 방식으로 통신을 주고 받을지를 정의하는 과정을 나타냄

설계시 고려 사항

- RESTful 원칙 준수 및 명확하고 일관된 명명 규칙
- 보안 및 성능 최적화
- 버전 관리 및 하위 호환성

### 리소스 기반 설계: RESTful API

API 엔드포인트는 주로 리소스를 기반으로 설계됨

예를 들어 사용자, 제품, 주문과 같은 도메인 개체를 리소스로 정의하고 이를 기준으로 엔드포인트를 구성

엔드 포인트의 경로는 명확하고 일관성있게 설계되어야함

일반적으로 리소스를 나타내는 경로와 HTTP 메소드를 조합하여 정의

리소스 간 관계를 URL 구조에 반영하여 계층적으로 표현

<img width="698" alt="image" src="https://github.com/user-attachments/assets/6961b228-c3bd-44d6-9752-361d12e5970e">

### 파라미터

파라미터는 URL에 포함되는 변수로 특정 리소스에 접근하거나 식별하기 위해 사용

주로 RESTful API에서 리소스의 고유 식별자를 전달하기 위해 사용

파라미터를 통해 리소스 계층 구조를 명확히 표현하고 정확한 리소스를 식별할 수 있음

잘못된 파라미터를 처리할 수 있는 로직이 필요할 수 있음

### 쿼리 스트링

쿼리 스트링은 URL 끝에 ? 문자와 함께 추가되며 key=value 쌍으로 이뤄짐

여러 개의 쿼리 스트링 파라미터는 & 기호로 구분됨

주로 필터링, 정렬, 페이지네이션 등의 데이터를 전달할 때 사용

쿼리 스트링은 주로 HTTP GET 요청에서 사용됨

<img width="698" alt="image" src="https://github.com/user-attachments/assets/a9ad2aaf-61aa-442e-909f-0a547202d405">

### 파라미터와 쿼리스트링

- 비교
    - 파라미터는 URL 경로의 일부로 리소스 식별자와 연결
    - 쿼리 스트링은 선택적인 매개변수로 요청에 추가적인 정보 제공
- 인코딩
    - URL에서 사용되는 파라미터와 쿼리 스트링은 UTF-8로 인코딩되어야 함
    - 특수 문자나 공백 등은 URL 인코딩을 통해 안전하게 전달되어야 함
    - 자바스크립트에서 encodeURIComponent 혹은 decodeURIComponent 함수 활용 가능

<img width="698" alt="image" src="https://github.com/user-attachments/assets/3a8a017a-3c00-47f9-a01f-75888d9a9763">

### API 엔드포인트 설계 순서

1. 리소스 식별: API가 제공할 주요 리소스 식별, 이는 사용자, 제품, 주문 등과 같은 비즈니스 개체 포함
2. HTTP 메소드 정의: 각 리소스에 대해 지원할 HTTP 메서드 정의
3. URI 설계: 각 리소스와 연결된 URI 설계
4. 파라미터 및 쿼리 스트링 정의: 필요한 경우 경로 파라미터와 쿼리 스트링을 정의
5. 응답 포맷 정의: API가 반환할 데이터의 형식을 정의하고 각 엔드포인트의 예상 응답과 상태 코드 정의
6. 개발: 설계한 내용에 따라 라우터를 작성
7. 문서화: API를 사용하는 개발자들이 이해하기 쉽도록 각 엔드포인트의 사용 방법, 요청 및 응답 예시를 포함한 문서 작성

## API 문서화 방법

### API 문서 작성의 목적

- API 이해 돕기: API 문서는 AP가 무엇을 하는지 어떤 기능을 제공하는지를 명확히 설명함
- 사용법 제공: API 문서는 각 엔드포인트의 경로, 사용가능한 HTTP 메서드, 필요한 파라미터와 쿼리 스트링 등을 포함하여 API를 어떻게 호출해야하는지에 대한 구체적인 사용법 제공
- 오류 예방: API 호출 시 발생할 수 있는 오류 상황과 오류 코드를 설명
- 버전 관리

### API 문서의 구성 요소 === API의 구성 요소

- HTTP 메소드와 엔드포인트
    - GET, POST, PUT, DELETE
    - URI
- 파라미터와 쿼리 스트링
    - 이름 및 역할
- 요청 본문
    - 각 필드의 타입
- 요청 및 응답 예시
    - 본문
    - 응답 상태 코드
- 기타 내용
    - 제한 및 제약 사항
    - 도움말

### API 문서 작성 방법: Swagger/OpenAPI 활용

- Swagger는 API를 설계, 빌드, 문서화할 수 있는 도구와 스펙이며 OpenAPI Apecification(OAS)을 사용하여 API를 설명하는 표준
- 자동화된 문서 생성
- API 테스트
- 표준화된 형식

![Uploading image.png…]()

- 프로젝트에서 작성된 코드로부터 Swagger 또는 OpenAPI 문서를 자동 생성 가능
- 이러한 자동 생성은 대부분의 언어에서 라이브러리로 제공되는 기능
    - Java Spring: SpringFox, SpringDox
    - Node.js: swaggere-jsdoc
    - Python Flask: flask_restplus
- 장점
    - 일관성 유지: 코드와 문서의 일관성을 유지하여 문서화의 정확성을 높일 수 있음
    - 자동화: 문서화를 자동화하여 개발자가 수동으로 문서를 작성하고 유지보수하는 부담을 줄일 수 있음
- 고려 사항
    - 자동 생성된 문서가 모든 세부 사항을 포괄하지 않을 수 있으므로 추가적인 설명이나 예시를 수동으로 보완할 필요가 있음

### API 문서 작성 방법: Postman, Insomnia 등 플랫폼 활용

API 문서를 작성할 때 Postman, Insomnia와 같은 플랫폼을 활용하면 문서화 과정이 간편해짐

- API 테스트 환경 제공
    - 설정 및 구성: 각 플랫폼에서 API 요청을 구성하고 테스트 가능, 요청 URL, HTTP 메서드, 헤더, 파라미터, 요청 본문 등을 설정하여 API 호출 시도 가능
    - 응답 확인: API 요청에 대한 응답을 실시간으로 확인하고 응답 데이터와 상태 코드를 분석하여 API 동작을 검증할 수 있음
- 자동 문서화 기능
    - 요청 및 응답 기록: 각 요청과 응답의 세부 정보를 기록하여 API의 사용 예시를 문서화 가능
    - 컬렉션 생성: API 엔드포인트를 그룹화하여 컬렉션을 만들고, 각 컬렉션에 설명을 추가하여 API의 구조와 사용 방법을 문서화 가능
- 사용 예시 포함
    - 샘플 요청 및 응답: 실제 API 호출 예시와 함께 샘플 요청 및 응답 데이터를 문서에 포함시켜 사용자들이 쉽게 이해할 수 있도록 함.
    - 코드 생성 기능: 다양한 언어와 프레임워크에서 사용할 수 있는 코드 예시를 자동으로 생성하여 API 호출 방식 문서화 가능
- 협업 및 공유
    - 팀 협업 도구: 팀원들과 API 문서를 공유하고 실시간으로 협업할 수 있는 기능 제공, 이는 문서의 정확성을 유지하고 최신 상태로 업데이트하는데 유용
    - 버전 관리: API의 버전을 관리하고 각 버전에 대한 문서를 별도로 작성하여 API의 변경 이력 추적 가능
- 외부 문서화 도구 연동
    - API 문서 생성: API 테스트 도구에서 작성된 문서를 Markdown, HTML, PDF 등 다양한 형식으로 내보내어 외부 문서화 도구와 연동 가능
    - 문서화 템플리 사용: 미리 정의된 템플릿을 사용하여 일관된 스타일과 형식으로 문서 작성 가능

## JSON과 XML 데이터 포맷

### JSON(JavaScript Object Notation)

- 경량의 데이터 교환 형식으로 사람과 기계가 모두 이해하기 쉽도록 설계된 텍스트 기반의 데이터 형식
- 가독성: 텍스트 기반으로 사람이 쉽게 읽고 쓸 수 있음
- 간결성: 불필요한 태그가 없고 구조가 단순하여 데이터 크기가 작음
- 편의성: 다양한 프로그래밍 언어에서 지원하며 파싱이 용이
- 데이터 타입: 문자열, 숫자, 배열, 객체, 불리언, Null 등 다양한 데이터 타입 지원

### XML(eXtensible Markup Language)

- XML은 다목적 마크업 언어로 데이터를 구조화하고 전송하는 데 사용되는 텍스트 기반의 형식
- 확장성: 사용자가 자신만의 태그를 정의하여 데이터 구조화 가능
- 복잡성: 더 많은 태그를 필요로 하며 데이터 크기가 상대적으로 크고 파싱이 복잡할 수 있음
- 메타데이터: 태그를 사용하여 데이터에 메타데이터 추가 가능
