# 시스템 아키텍쳐 설계의 개요

## 아키텍쳐

시스템 구성 요소와 이들 간의 관계를 정의하는 구조적 설계

시스템을 구성하는 요소(하드웨어, 소프트웨어, 데이터 등)와 이들 간 상호작용을 정의하는 고수준의 설계 구조

시스템의 전반적 구조를 설계하여 성능, 확장성, 안정성, 유지보수성을 보장

## 주요 요소

- 구성 요소(Component): 시스템을 구성하는 기본 단위, 예를 들어 소프트웨어 모듈, 하드웨어 장치, 네트워크 장비
- 인터페이스(Interfaces): 구성 요소 간 상호작용을 정의하는 규약, 데이터 전송, 명령어 실행
- 데이터 흐름(Data Flow): 시스템 내에서 데이터가 어떻게 이동하고 처리되는지를 설명
- 구성 요소 간 관계(Relationships): 시스템 각 구성 요소가 어떻게 연결되고 상호작용하는지를 정의

## 중요성

- 성능 최적화
- 확장 용이성: 예를 들어 마이크로서비스 아키텍쳐는 개별 서비스의 독립적인 확장을 가능하게 함
- 문제 해결 용이
- 모듈 별 독립적 업데이트와 패치
- 장애에 대한 고가용성과 신뢰성 제공
- 시스템 각 구성 요소를 독립적으로 테스트 가능
- 개발 비용 절감
- 최적화된 성능과 유지보수 용이성으로 운영 비용 절감

# 아키텍쳐 스타일

## 모놀리식 아키텍쳐

![image](https://github.com/user-attachments/assets/bf9782bb-8f72-484b-8657-032676f24d41)

### 단일 코드베이스

- 모놀리식 아키텍쳐는 모든 기능이 하나의 코드베이스 내에서 관리
- 사용자 인터페이스, 비즈니스 로직, 데이터 접근 로직 등 모든 구성 요소가 통합되어 하나의 앱 형성
- 이로 인해 코드 관리가 상대적으로 단순하며 모든 기능이 같은 코드 베이스에서 동작하기 떄문에 일관성 유지 가능

### 강한 결합도

- 앱 구성 요소 간 의존성이 높음
- 하나의 모듈이 변경되면 다른 모듈에도 영향
- 강한 결합은 전체 앱 동작을 보장하지만 변경 사항이 전체 시스템에 영향을 미치기 떄문에 테스트와 수정이 어려움

### 단일 배포 단위

- 전체 앱이 하나의 단위로 패키징되어 배포
- 모든 구성 요소가 함께 배포되어야 하며 작은 변경이라도 전체 앱 재배포 필요
- 배포 과정이 간편하지만 리스크가 클 . 수있으며 배포 과정 중 오류가 전체 시스템에 영향을 줄 수 있음

### 장점

- 단순한 개발과 배포
- 통합 테스트 용이
- 기술 스택의 일관성

### 단점

- 유지보수의 어려움
- 확장성 제한
- 배포 리스크

### 적용 예시

- 초기 개발과 배포가 신속해야하는 소규모 프로젝트나 스타트업
- 일관된 환경이 필요한 프로젝트
- 빠른 시장 출시 필요
- 모든 기능이 긴밀하게 결합되어야하는 시스템

### → 모놀리식 아키텍쳐는 초기 개발과 배포가 간단하여 소규모 프로젝트에 적합하지만 시스템이 커지며 확장성과 유지보수 측면에서 도전과제가 발생

## 클라이언트-서버 아키텍쳐 (3Tier)

![image](https://github.com/user-attachments/assets/8035d14e-c607-4925-b083-aae26dae0c3c)

네트워크를 통해 클라이언트와 서버 간 작업을 분리하는 소프트웨어 구조

클라이언트는 사용자 요청을 서버에 전달하고 서버는 요청을 처리한 후 결과를 클라이언트에 응답

### 구성요소

- 클라이언트: 사용자 인터페이스 제공, 사용자 입력을 받아 서버에 요청 전송하는 소프트웨어, 웹 브라우저, 모바일 앱, 데스크톱 앱 등이 포함
- 서버: 클라이언트 요청 처리, 데이터 저장, 비즈니스 로직을 수행하는 소프트웨어, 웹 서버, 데이터베이스 서버, 파일 서버 등이 포함
- 네트워크: 클라이언트와 서버 간 통신을 담당하는 네트워크 인프라, 인터넷, 로컬 네트워크 등이 사용
- 프로토콜: 클라이언트-서버 간 통신 규약을 정의하는 표준, HTTP, HTTPS, FTP, TCP/IP 등이 사용

### 장점

- 데이터의 중앙 집중화
- 서버 측과 클라이언트 측의 독립적인 관리로 유지보수 용이성
- 확장성
- 안정성 및 신뢰성

### 단점

- 클라이언트 요청에 따른 서버 부하
- 네트워크 의존성
- 서버 비용
- 복잡성 증가

### 적용 사례

- 웹 앱
- 모바일 앱
- 엔터프라이즈 앱: 대규모 기업에서 사용하는 앱으로 중앙 서버에서 데이터를 관리하고 비즈니스 로직 수행
- 온라인 게임

## 마이크로서비스 아키텍쳐(MSA)

![image](https://github.com/user-attachments/assets/ad7367e3-de5a-49dc-9185-c3bee45e2135)

앱을 여러 개의 독립적이고 작은 서비스들로 나누어 개발하는 소프트웨어 설계 방식

각 서비스는 독립적으로 배포 및 운영될 수 있으며 각자의 비즈니스 로직을 갖고 있음

이 서비스들은 일반적으로 RESTful API 또는 메시지 브로커를 통해 서로 통신함

### 구성 요소

- 독립적인 서비스: 각 서비스는 독립적으로 개발, 배포, 운영될 수 있음, 특정 비즈니스 기능을 담당하며 독립적인 데이터 저장소를 가질 수 있음
- API 게이트웨이: 클라이언트 요청을 적절한 서비스로 라우팅하고 각 서비스의 엔드포인트 관리
- 서비스 간 통신: RESTful API, 메시지 브로커, gRPC 등 다양한 통신 방식을 통해 서비스 간 데이터를 주고 받음
- 데브옵스 도구: CI/CD 파이프라인, 컨테이너화 도구(Docker), 오케스트레이션 도구(Kubernetes) 등으로 서비스의 지속적 통합 및 배포 지원

### 장점

- 각 서비스가 독립적으로 확장될 수 있어 트래픽만 많은 서비스만 별도로 확장할 수 있음
- 코드베이스가 작어져 유지보수가 용이하며 각 서비스가 독립적으로 배포되므로 기능 추가나 버그 수정이 다른 서비스에 영향을 미치지 않음
- 서로 다른 팀이 독립적으로 서비스 개발을 진행할 수 있어 개발 속도 향상
- 다양한 기술 스택을 사용할 수 있어 최적의 기술 선택 가능

### 단점

- 복잡한 관리: 서비스가 많아질수록 관리 복잡, 서비스 간 통신과 데이터 일관성 유지가 어려움
- 분산된 데이터 관리: 각 서비스가 독립적인 데이터 저장소를 가질 수 있어 데이터 일관성 유지가 어려움
- 배포 복잡성: 각 서비스가 독립적으로 배포되므로 배포 파이프라인이 복잡해질 수 있음

### 적용 예시

- 대규모 프로젝트
- 빈번한 배포 및 업데이트가 필요
- 다양한 기술 스택 필요
- 분산 팀 협업

### → 마이크로서비스 아키텍쳐는 확장성과 유지보수 용이성을 제공하지만 관리와 배포의 복잡성을 수반

## 서버리스 아키텍쳐

![image](https://github.com/user-attachments/assets/4a5bcd4e-121e-430d-b380-4d949a138853)

개발자가 서버의 관리와 확장 문제를 신경쓰지 않고 비즈니스 로직에 집중할 수 있도록 하는 클라우드 컴퓨팅 모델

사용자는 함수나 이벤트에 의해 트리거되는 코드만 작성하면 되며 서버 인프라스트럭처 관리가 자동으로 처리

### 구성 요소

- 함수: 서버리스 아키텍쳐의 핵심 구성 요소로 특정 이벤트에 의해 실행되는 코드 블록
    - AWS Lambda, Azure Functions, Google Cloud Functions 등이 대표적
- 트리거: 함수의 실행을 유발하는 이벤트로 HTTP 요청, 데이터베이스 변경, 파일 업로드, 타이머 등 다양한 형태
- API 게이트웨이: 클라이언트 요청을 서버리스 함수로 라우팅
    - AWS API Gateway, Azure API Management 등이 사용
- 데이터 저장소: 함수의 데이터 저장 및 관리에 사용되는 서비스로 NoSQL 데이터베이스, 관계형 데이터베이스 등 존재
    - AWS DynamoDB 등이 있음

### 장점

- 비용 효율성: 사용한 만큼만 비용을 지불하는 모델로 비용 절감 효과가 큼
- 자동 확장: 트래픽 변화에 따라 자동으로 리소스를 확장하거나 축소하여 과도한 자원 사용 방지
- 쉬운 관리: 서버 관리 및 인프라 설정을 클라우드 제공 업체가 자동으로 처리하므로 개발자가 비즈니스 로직에 집중 가능
- 빠른 배포: 함수 단위의 독립적 배포가 가능하여 빠른 개발과 배포 가능

### 단점

- 실행 시간 제한: 함수 실행 시간이 제한되어있어 장시간 실행이 필요한 작업에는 부적합, 대부분의 서버리스 플랫폼은 최대 실행 시간 제한
- 상태 관리 어려움: 서버리스 함수는 상태를 유지할 수 없기 떄문에 상태 관리나 지속적 연결이 필요한 작업에는 제한이 있음
- 디버깅 및 모니터링 어려움: 특성상 디버깅과 모니터링이 복잡할 수 있으며 로그 추적이 어려울 수 있음

### 적용 사례

- 이벤트 기반 앱: 실시간 데이터 처리, 파일 업로드, 스트리밍 처리 등 이벤트 중심 앱
- 빠른 프로토타입 및 MVP 개발: 빠르게 아이디어를 검증하고 제품 초기 버전을 신속하게 개발하고 배포해야할 때
- 마이크로서비스 아키텍쳐 일부를 서버리스 함수로 처리할 때
- 스케일 아웃이 중요한 작업: 불규칙한 트래픽 패턴을 가진 앱이나 대규모 분산 처리 작업

### → 서버리스 아키텍쳐는 서버 관리의 부단을 줄이고 비용 효율성을 높이며, 빠른 배포와 자동 확장 기능 제공, 그러나 실행 시간 제한, 상태 관리의 어려움 등 일부 제한 사항을 고려하여 적절한 상황에서 활용하는 것이 중요

# 아키텍쳐 설계 과정

## 1. 요구사항 분석: 기능적 요구사항 vs 비기능적 요구사항

### 기능적 요구사항

- 정의: 시스템이 수행해야하는 구체적인 기능이나 작업을 정의
- 목표: 사용자가 시스템을 통해 수행하려는 동작 지원
- 예시
    - 사용자 관리: 사용자 계정 생성, 수정, 삭제
    - 상품 검색: 상품 검색 및 필터링
    - 주문 처리: 장바구니에 상품 추가 및 주문 완료
    - 결제 기능

### 비기능적 요구사항

- 정의: 시스템 성능, 보안, 가용성 등 기능 외적인 속성 정의
- 목표: 시스템 품질과 사용자 경험 개선
- 예시
    - 성능: 시스템은 2초 이내 모든 요청에 응답해야함
    - 보안: 모든 사용자 데이터는 암호화되어 저장해야함
    - 가용성: 시스템은 연준무휴 99.9%의 가용성을 유지해야함
    - 확장성: 시스템은 증가하는 사용자 수에 맞춰 확장 가능해야함

## 1. 요구사항 분석: 요구사항 수집 및 문서화

### 요구사항 수집

- 이해관계자 인터뷰
- 설문 조사
- 팀 브레인스토밍

### 요구사항 문서화

- 요구사항 명세서
    - 수집된 모든 요구사항을 체계적으로 정리한 문서, 기능적 및 비기능적 요구 사항 포함
    - 포함 항목: 요구사항 ID, 제목, 설명, 우선순위, 수용 기준
- 사용자 스토리
    - 간단한 서술형 문서로 사용자가 시스템에서 달성하려는 목표를 설명
    - 형식: “As a [user], I want [기능] so that [목표/이유]”
- 기능 명세서
    - 각 기능에 대한 상세 설명을 제공하는 문서, 요구사항 명세서의 일부로 포함 가능
    - 포함 항목: 기능 ID, 제목, 설명, 입력 및 출력, 수행 단계

## 2. 요구사항 분석: 시스템 모델링

### 유스케이스 다이어그램

- 시스템과 사용자의 상호작용을 시각적으로 표현하여 시스템 기능 요구사항을 이해하는데 도움을 줌
- 구성 요소
    - 액터: 시스템 외부에서 상호작용하는 사용자 또는 시스템
    - 유스케이스: 사용자가 시스템을 통해 수행할 수 있는 기능이나 작업
    - 시스템 경계: 유스케이스와 액터가 상호작용하는 시스템 범위를 나타내는 박스
- 활동 예시: 온라인 쇼핑몰
    
    ![image](https://github.com/user-attachments/assets/44d37228-8dcd-4fc2-bcd3-45b8d682d2c5)

    
    - 액터: 고객, 관리자
    - 유스케이스
        - 고객: 상품 검색, 장바구니에 추가, 결제
        - 관리자: 상품 추가, 재고 관리, 주문 처리
    - 설명: 유스케이스 다이어 그램에서 고객이 상품을 검색하고 장바구니에 추가하고 결제하는 과정을 시각화
    관리자 측면에서는 상품을 추가하고 재고 관리하는 과정도 나타낼 수 있음

### 클래스 다이어그램

- 목적: 시스템 클래스 구조를 정의하고 각 클래스의 속성과 메서드, 클래스 간 관계 설명
- 구성 요소
    - 클래스: 데이터와 기능을 포함하는 객체의 정의
    - 속성
        - 클래스가 가진 데이터 요소
        - 메서드: 클래스가 제공하는 기능
    - 관계: 클래스 . 간상속, 연관, 집합 등의 관계
- 활용 예시: 온라인 쇼핑몰
    
    ![image](https://github.com/user-attachments/assets/ef276750-2634-4f70-aa42-8a4502cafdeb)

    
    - 클래스: 고객, 주문, 상품
    - 속성
        - 고객 클래스: 고객 ID, 이름, 이메일
        - 주문 클래스: 주문 ID, 주문일, 총액
        - 상품 클래스: 상품 ID, 이름, 가격
    - 관계
        - 고객은 여러 주문 가능(1:N 관계)
        - 주문은 여러 상품 포함 가능(N:M 관계)
    - 설명
        - 클래스 다이어그램에서 고객, 주문, 상품 클래스를 정의하고 이들 간 관계를 명확히 함
        - 고객 클래스는 주문을 생성하고 주문 클래스는 여러 상품을 포함하며 상품 클래스는 주문에 포함

### 시퀀스 다이어그램

![image](https://github.com/user-attachments/assets/5ab9bc8c-1997-4280-be86-cb0aae253ce5)

- 목적: 객체 간 메시지 흐름과 상호 작용을 시간 순서대로 표현하여 시스템 동작 과정을 명확히 함
- 구성 요소
    - 객체: 상호작용에 참여하는 시스템 구성 요소
    - 메시지: 객체 간 호출 및 응답
    - 타임라인: 메시지 교환의 시간적 순서
- 활용 예시: 사용자 로그인 프로세스
    - 객체: 사용자, 로그인 페이지, 인증 서버
    - 메시지
        - 사용자 → 로그인 페이지: 로그인 정보 입력
        - 로그인 페이지 → 인증 서버: 인증 요청
        - 인증 서버 → 로그인 페이지: 인증 결과 응답
        - 로그인 페이지 → 사용자: 로그인 성공/실패 메시지
    - 설명: 시퀀스 다이어그램에서 사용자가 로그인 정보를 입력하고 로그인 페이지가 인증 서버에 요청을 보내는 과정, 인증 서버가 응답을 보내는 과정을 시간 순서대로 나타냄

## 2. 요구사항 분석: 데이터 흐름과 상호작용 모델링

### 데이터 흐름 다이어그램

![image](https://github.com/user-attachments/assets/03beee01-c2a1-43eb-899b-29c63451cf18)

- 목적: 시스템 내 데이터 흐름과 처리를 시각적으로 표현하여 시스템 동작을 이해
- 구성 요소
    - 프로세스: 데이터를 처리하는 시스템 작업
    - 데이터 흐름: 데이터가 시스템 내 이동하는 경로
    - 데이터 저장소: 데이터를 저장하는 장소
    - 외부 엔티티: 시스템 외부에서 데이터를 생성하거나 소비하는 주체
- 활용 예시
    - 고객 주문 데이터가 시스템 내에서 처리되고 데이터베이스에 저장되며 재고 관리 시스템으로 전달되는 흐름을 시각화

### 상호작용 다이어그램

- 목적: 객체 간 상호작용과 메시지 흐름을 상세히 모델링하여 시스템 동작을 명확히 함
- 구성 요소
    - 객체: 상호작용에 참여하는 시스템의 구성 요소
    - 메시지: 객체 간 호출 . 및응답
    - 활동: 객체 간 상호작용 과정
- 활용 예시
    - 고객이 상품을 검색하고 검색 결과를 표시하기 위해 서버와 상호작용하는 과정을 시각화

## 3. 구조 설계: 시스템 모듈 분할

시스템을 더 작은 단위로 나눠 관리 및 확장성을 높이고 각 모듈의 역할과 책임을 명확히 함

모듈을 분할하는 것은 요구사항에 맞춰 적합한 아키텍쳐 패턴을 적용하기 용이하게 함

### 방법

- 기능적 분할: 비슷한 기능을 하는 요소들을 한 모듈로 묶음
- 계층적 분한: 프레젠테이션, 비즈니스 로직, 데이터 액세스 등의 계층으로 분할
- 도메인 기반 분할: 특정 도메인(예: 사용자 관리, 주문 처리 등)에 따라 모듈화

### 활용

- 요구사항 분석 결과 활용: 수집된 요구사항을 바탕으로 시스템 기능 분할
- 시스템 모델링 활용: UML 다이어그램을 사용하여 모듈 간 관계와 인터페이스 정의

### 예시

- 이커머스 앱: 사용자 관리 모듈, 제품 관리 모듈, 주문 처리 모듈, 결제 처리 모듈 등으로 분할

## 3. 구조 설계: 컴포넌트 간 인터페이스 정의

- 목적: 모듈 간 명확한 통신 규칙을 정의하여 상호작용을 원활하게 하고 결합도를 낮춤

### 방법

- API 설계: 각 모듈이 외부에 노출하는 인터페이스 정의
- 계약 기반 개발: 각 모듈의 입력, 출력 및 동작을 명확히 정의하여 계약을 수립
- 데이터 형식 정의: 모듈 간 주고받는 데이터의 형식과 구조를 정의

### 활용

- 요구사항 분석 결과 활용: 요구사항에 따른 인터페이스 요구사항을 반영
- 시스템 모델링 활용: 시퀀스 다이어그램을 사용하여 인터페이스 설계

### 예시

- RESTful API: HTTP 메서드를 사용하여 모듈 간 데이터 교환
- gRPC: 프로토콜 버퍼를 사용하여 고성능의 모듈 간 통신

## 4. 아키텍쳐 선택: 요구사항에 따른 적합한 아키텍쳐 패턴 선택

시스템 특성과 요구사항에 가장 적합한 아키텍쳐 패턴을 선택하여 최적의 성능과 유지보수성 확보

### 방법

- 요구사항 분석: 시스템의 기능적 및 비기능적 요구사항 분석
- 모듈 구조 분석: 모듈과 모듈 간 인터페이스 설계 내용에 대해 분석
- 패턴 특성 비교: 다양한 아키텍쳐 패턴의 장단점을 비교하여 선택
- 기술적 고려 사항: 팀의 기술 스택, 기존 시스템과의 호환성, 배포 전략 등을 고려

### 활용

- 요구사항 분석 결과 활용: 요구사항에 기반하여 적합한 아키텍쳐 패턴 선정
- 시스템 모델링 활용: 모델링을 통해 아키텍쳐 패턴 적용 시 구조와 상호작용 검토

### 예시

- 서버리스 아키텍쳐: 이벤트 기반 처리와 간헐적 트래픽에 적합
- 마이크로서비스 아키텍쳐: 독립적인 서비스 배포와 확장성이 필요한 대규모 시스템에 적합

# 시스템 설계 원칙

## 모듈화와 재사용성

### 모듈화

- 시스템을 독립적인 기능 단위로 나누어 설계하는 접근법
- 장점
    - 모듈 단위로 독립적 수정 및 업데이트 가능
    - 병렬 작업과 팀 간 협업 용이
    - 각 모듈 독립적 테스트 가능
- 예시: 전자 상거래 시스템에서 사용자 관리, 결제 처리 등을 모듈화하여 관리

### 재사용성

- 기존 개발한 모듈이나 컴포넌트를 새로운 시스템에서 반복적으로 사용하는 것
- 장점
    - 검증된 모듈을 활용하여 개발 속도 향상
    - 동일 기능을 다양한 시스템에서 제공
    - 중복된 개발 작업을 줄여 비용 절감
- 예시: 인증 모듈을 다양한 웹 앱에서 재사용

## 결합도와 응집도

### 결합도(Coupling)

- 모듈 간 의존성의 정도
- 결합도가 낮아지는 방향으로 설계
- 목표: 낮은 결합도
    - 모듈 간 독립성을 보장하고 변경 시 영향 최소화
    - 명확한 인터페이스 정의와 최소한의 데이터 공유
- 예시: API를 통해 모듈 간 통신을 처리하고 내부 데이터는 외부에 공개하지 않음

### 응집도(Cohesion)

- 모듈 . 내구성 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내는 지표
- 목표: 높은 응집도
    - 모듈이 단일 기능에 집중하고 명확한 책임 부여
    - 모듈이 하나의 역할이나 기능을 수행하도록 설계
- 예시: 사용자 프로필 모듈이 사용자 정보 관리와 프로필 사진 변경 기능을 포함

## 확장성 및 유연성

### 확장성

시스템이 데이터, 트래픽, 기능 요구 증가에 대응할 수 있는 능력

- 유형
    - 수평 확장: 서버나 인스턴스를 추가하여 시스템 용량 확대
    - 수직 확장: 기존 서버의 성능(메모리, CPU 등)을 업그레이드
- 방법
    - 모듈화: 독립적인 모듈로 설계하여 개별 모듈 확장 가능
    - 분산 처리: 부하 분산 및 클러스터링 적용
- 예시: 웹 서버 클러스터링을 통해 트래픽 증가에 대응

### 유연성

시스템이 변화하는 요구사항에 적응할 수 있는 능력

- 특징
    - 구성 요소 교체 용이: 모듈 간 독립성 확보
    - 기술적 적응: 새로운 기술이나 기능 추가 용이
- 방법
    - 추상화: 기능과 구현을 분리하여 유연성 증대
    - 플러그인 아키텍쳐: 모듈 추가 및 교체 용이
- 예시: 기능 추가를 위한 플러그인 시스템 적용

# DevOps와 CI/CD

## DevOps 개요

‘Development’와 ‘Operations’의 합성어로 소프트웨어 개발과 IT 운영을 통합하는 문화와 실천 방식을 의미

## 주요 원칙

- 협업: 개발팀과 운영팀 간 긴밀한 협력
- 자동화: 반복적인 작업의 자동화로 효율성 증대
- 지속적 개선: 피드백 루프를 통한 지속적인 프로세스 개선
- 고객 중심: 최종 사용자의 요구사항에 빠르게 대응
- 빠른 배포: 작은 단위의 변경사항을 자주 배포

## 도구와 기술

- 버전 관리: Git, GitHub, GitLab
- CI/CD: Jenkins, GitLab CI, CircleCI
- 컨테이너화: Docker, Kubernetes
- 구성 관리: Ansible, Puppet, Chef
- 모니터링: Prometheus, Grafana, ELK Stack
- 클라우드 플랫포미 AWS, Azure, Google Cloud Platform

## CI/CD의 개념 및 구성

![image](https://github.com/user-attachments/assets/342e81e7-bd9b-48d8-b3d8-4a4ac1ff8b55)

- CI(Continuous Integration): 개발자들이 코드 변경 사항을 주기적으로 중앙 저장소에 병합
- CD(Continuous Delivery/Deployment): 소프트웨어를 자동으로 빌드, 테스트하고 production 환경에 배포
- CI/CD 파이프라인
    - 코드 변경사항을 지속적으로 통합(CI)하고, 이를 자동으로 테스트하여 배포(CD)하는 일련의 단계
    - 자동화: 수동 작업을 최소화하고 일관된 프로세스 보장
    - 연속성: 코드 변경부터 배포까지 끊김없이 연결
    - 빠른 피드백: 각 단계에서 즉각적인 피드백 제공
    - 품질 보증: 자동화된 테스트로 소프트웨어 품질 향상
    - 빠른 배포: 작은 변경 사항을 자주 빠르게 배포 가능

## 일반적인 CI/CD 파이프라인 단계

1. 코드 커밋: 개발자가 코드를 버전 관리 시스템에 커밋
2. 빌드: 코드 컴파일 후 실행 가능한 형태로 만듦
3. 테스트: 단위 테스트, 통합 테스트 . 등실행
4. 정적 코드 분석: 코드 품질과 보안 취약점 검사
5. 스테이징 환경 배포: 운영 환경과 유사한 환경에 배포
6. 통합 테스트: 전체 시스템 레벨의 테스트 수행
7. 운영 환경 배포: 최종적으로 실제 운영 환경에 배포
8. 모니터링: 배포 후 시스템 성능과 오류를 모니터링

## 자동화의 중요성

- 빠른 피드백
- 일관성
- 효율성
- 신뢰성
- 보안: 정기적인 보안 검사로 취약점 사전 발견
- 스케일링: 대규모 배포와 관리 처리 용이

### → DevOps와 CI/CD는 개발과 운영의 경계를 허물고 소프트웨어 품질과 배포 속도를 향상시키는 핵심적인 접근 방식, 자동화된 파이프라인과 협업을 통해 효율적이고 신뢰성있는 소프트웨어 개발 지원
