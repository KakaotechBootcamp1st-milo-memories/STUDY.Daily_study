# 데이터베이스 개요

## 데이터베이스 정의

데이터베이스는 체계적으로 구조화된 데이터 집합

데이터의 저장, 검색, 수정, 삭제 등의 작업을 효율적으로 수행하기 위해 사용

데이터베이스는 일반적으로 데이터베이스 관리 시스템(DBMS)에 의해 제어됨

## 데이터베이스의 특징

- 데이터 독립성: 데이터 구조 변경 시 응용 프로그램에 영향을 미치지 않도록 논리적, 물리적 독립성 유지
- 동시성 제어: 여러 사용자가 동시에 데이터에 접근할 수 있게 하여 일관된 상태 유지
- 데이터 보안성
- 복구성
- 데이터 공유성
- 성능 최적화

## 데이터베이스와 파일 시스템의 차이

- 데이터 구조화
    - 데이터베이스: 데이터가 테이블, 뷰, 인덱스 등 구조화된 형태로 저장
    - 파일 시스템: 데이터가 파일과 폴더로 저장되며 구조화되지 않은 경우가 많음
- 데이터 무결성
    - 데이터베이스: 무결성 제약 조건을 통해 데이터 일관성 유지
    - 파일 시스템: 별도의 무결성 제약 조건이 없어 일관성 유지가 어려움
- 동시성 제어
    - 데이터베이스: 여러 사용자가 동시에 데이터 접근 가능
    - 파일 시스템: 동시 접근 시 데이터 손상 가능성 높음
- 데이터 검색
    - 데이터베이스: SQL과 같은 고급 쿼리 언어를 사용하여 데이터를 효율적으로 검색
    - 파일 시스템: 파일 탐색 기능에 의존

## 데이터베이스 모델 종류

- 관계형 데이터베이스
    - 데이터를 테이블 형식으로 저장하고 SQL을 사용해 데이터 관리
    - MySQL, PostgreSQL, Oracle
- 분산 데이터베이스
    - 데이터를 여러 물리적 위치에 분산하여 저장하고 관리
    - Google Spanner, Apache Cassandra
- NoSQL 데이터베이스
    - 비정형 데이터를 효율적으로 저장하고 처리하기 위한 데이터베이스
    - MongoDB, CouchDB
- 그래프 데이터베이스
    - 데이터를 노드, 엣지, 속성 형태로 저장하여 복잡한 관계를 쉽게 표현하고 쿼리
    - Neo4j

# 관계형 데이터베이스

- 테이블
    - 데이터를 행과 열로 구성된 2차원 구조로 표현
    - 각 테이블은 고유한 이름을 가짐
- 행(레코드)
    - 테이블의 가로줄
    - 하나의 개체에 대한 정보 포함
- 열(필드)
    - 테이블의 세로줄
    - 특정 속성에 대한 정보 표현
- 트랜잭션
    - 데이터베이스에서 수행하는 작업의 논리적 단위
    - 데이터베이스에서 데이터를 안전하게 관리하기 위한 기본적인 개념으로 여러 단계의 작업을 한 덩어리로 묶어서 한 번에 처리

![image](https://github.com/user-attachments/assets/57c30ba9-fa64-4762-a4b0-35b9e02efe5b)

## ACID

데이터 무결성을 유지하기 위한 주요 특성

### 1. Atomicity(원자성)

- 트랜잭션의 모든 작업이 모두 성공하거나 모두 실패하는 것을 보장

### 2. Consistency(일관성)

- 트랜잭션이 완료되면 데이터베이스는 일관된 상태 유지
- 트랜잭션 실행 전과 후의 데이터 상태는 데이터베이스의 모든 제약 조건을 만족해야함
- 데이터베이스의 무결성 제약 조건(예: 외래 키, 고유 키 제약 조건)이 항상 만족되어야 함

### 3. Isolation(고립성)

- 동시에 실행되는 트랜잭션이 서로에게 영향을 미치지 않도록 함
- 하나의 트랜잭션이 완료될 때까지 다른 트랜잭션이 그 중간 상태를 볼 수 없음
- 여러 사용자가 동시에 같은 데이터를 수정할 때 트랜잭션 간섭을 방지하여 데이터 일관성 유지

### 4. Durability(지속성)

- 트랜잭션이 성공하면 그 결과는 영구적으로 저장
- 시스템 장애가 발생해도 결과는 손실되지 않음

## 관계형 데이터베이스의 특징

### 데이터 무결성(Data Integrity)

- 참조 무결성: 외래 키를 통해 테이블 간 관계를 유지하고 데이터 일관성을 보장
- 고유성: 고유 키와 유니크 제약 조건을 통해 중복되지 않는 데이터 보장
- 제약 조건: NOT NULL, CHECK 등 제약 조건을 통해 데이터 유효성 보장

### 정규화(Nomalization)

- 데이터 중복을 최소화하고 데이터 구조를 효율적으로 설계하기 위해 정규화 과정을 적용
- 제1정규형부터 제3정규화까지의 정규화 단계로 데이터 중복을 줄이고 무결성을 향상

### 강력한 쿼리 언어(SQL)

- 데이터를 정의, 조회, 수정, 삭제하기 위한 표준 SQL을 사용

### 트랜잭션 관리

- BEGIN, COMMIT, ROLLBACK 명령어로 트랜잭션 관리
- 트랜잭션 단위로 데이터 변경을 처리하여 데이터 무결성과 일관성 유지

### 인덱스

- 데이터 검색 속도를 향상시키기 위해 인덱스 사용
- B-Tree, Hash 등 다양한 인덱스 구조를 지원하여 효율적 데이터 접근 가능

### 확장성

- 수직적 확장(서버 성능 향상)을 통해 데이터베이스 성능 향상 가능
- 클러스터링, 분산 데이터베이스 기술 사용 가능

## 데이터 베이스 수평적 확장 방법

### 샤딩(Sharding)

- 데이터베이스를 여러 개의 분할된 부분(샤드)으로 나누어 분산 저장
- 각 샤드는 고유한 데이터 하위 집합을 저장하고 독립적으로 쿼리 처리
- 샤딩 키를 선택하여 데이터를 균등 분배

### 리플리케이션

- 데이터를 여러 노드에 복제하여 읽기 성능 향상
- 마스터-슬레이브 복제를 통해 쓰기 작업은 마스터 노드에서, 읽기 작업은 슬레이브 노드에서 처리
- 다중 마스터 복제를 통해 쓰기 작업도 분산

## 관계형 데이터베이스의 수평적 확장이 어려운 이유

### 데이터 일관성 유지의 어려움

- 분산된 여러 노드에서 데이터 일관성을 유지하는 것이 복잡하고 어려움
- 트랜잭션이 여러 노드에 걸쳐있는 경우 ACID를 보장하기 어려움

### 복잡한 조인 연산

- 관계형 데이터베이스는 조인을 통해 여러 테이블에서 데이터를 결합하는데 데이터가 분산되면 조인 연산이 복잡해지고 성능이 저하

### 트랜잭션 처리

- RDBMS는 트랜잭션 처리 시 일관성을 보장하기 위한 강력한 잠금 메커니즘을 사용하는데 분산 환경에서 병목 현상 초래 가능

### → 따라서 데이터베이스의 수평적 확장이 필요한 경우 분산 SQL 데이터베이스를 고려하는 것이 좋음

## 관계형 데이터베이스 정리

### 장점

- 정규화
- 강력한 쿼리 언어
- 데이터 무결성(일관성) 보장
- 안정성: 트랜잭션 관리 및 롤백 기능 사용

### 단점

- 확장성 제한: 수직적 확장(서버 성능 향상)만 가능하여 대규모 데이터 처리에 한계
- 유연성 부족: 스키마가 고정되어 있어 데이터 구조 변경이 어려움
- 성능: 매우 큰 데이터 셋의 경우 성능 저하

### 사용 상황

- 데이터 일관성 중요: 금융, 은행, ERP 시스템 등 데이터 무결성이 중요한 앱에서 사용
- 고정된 스키마: 데이터 구조가 자주 변경되지 않는 환경

# 비관계형 데이터베이스(NoSQL)

Not Only SQL의 약자로 고정된 스키마를 따르지 않고 다양한 데이터 모델을 지원하는 데이터베이스

## 다양한 데이터 모델 지원

![image](https://github.com/user-attachments/assets/3ac97e17-7f0d-4d93-bde0-4ad958fa0b4c)

### 문서형 데이터베이스

- JSON, BSON 형식의 문서 데이터를 저장
- 각 도큐먼트는 고유한 키로 식별되며 내부에서 다양한 필드와 값 포함
- 문서의 집합을 컬렉션이라 함

### 키-값 스토어

- 키와 값 쌍으로 데이터 저장
- 빠른 읽기와 쓰기 성능을 제공하며 메모리 기반 데이터베이스로서 캐싱에 매우 유리
- Redis, DynamoDB

### 와이드 칼럼 스토어

- 테이블을 키와 여러 컬럼으로 구성하여 데이터 저장
- 각 행은 여러 개의 컬럼 패밀리로 구성되며 데이터 모델이 유연하여 다양한 쿼리에 적합
- Appache Cassandra, HBase

### 그래프 데이터베이스

- 노드와 엣지로 데이터를 저장하며 복잡한 관계를 효율적으로 표현
- 네트워크와 관계 구조를 사용하여 데이터를 저장하고 쿼리
- Neo4j, JanusGraph

## 비관계형 데이터베이스 특징

### 유연한 스키마

- 데이터 구조가 고정되어 있지 않아 데이터 모델이 필요에 따라 동적으로 변경 가능
- 앱 요구사항이나 데이터 형식의 변화에 대응하는 데 유리

### 수평적 확장성

- 데이터베이스가 여러 서버에 데이터를 분산하여 저장, 처리 가능하며 데이터 베이스가 더 많은 트래픽과 데이터 증가 처리 가능

### 고성능

- 대부분의 NoSQL 데이터베이스는 높은 처리량을 제공하며 특히 분산된 환경에서의 읽기 및 쓰기 성능이 뛰어남
- 이는 데이터베이스가 대규모 데이터의 집합을 효율적으로 처리할 수 있음을 의미

### 다양한 데이터 모델

- 다양한 데이터 모델을 지원하며 각 데이터 모델은 특정 사용 사례와 데이터 패턴에 맞게 최적화되어 있음

### 비구조적 데이터 처리

- 비구조적 데이터를 다루는데 유리하며 대용량 데이터 저장과 분석에 적합
- 특히 웹 앱과 소셜 미디어 플랫폼 등에서 많이 사용

### 분산 데이터베이스

- 데이터 복제와 샤딩을 통해 데이터베이스 가용성을 높이고 장애 복구 지원
- 데이터베이스의 신뢰성과 내결함성 향상

## 비관계형 데이터베이스 정리

### 장점

- 수평적 확장성: 여러 서버에 데이터를 분산 저장하여 용량과 성능 확장에 용이
- 유연한 스키마

### 단점

- 일관성 보장이 어려움
- 제한된 쿼리 기능
- 표준화 부족: 데이터베이스마다 쿼리 언어 및 API가 다름

### 사용 상황

- 대규모 데이터 처리: 소셜 네트워크, IoT, 빅데이터 분석 등 대규모 데이터 및 비정형 데이터를 처리하는 데 사용 가능
- 유연한 데이터 구조 필요: 데이터 구조가 자주 변경되는 앱에서 사용 가능

# RDBMS vs 문서형 데이터베이스

![image](https://github.com/user-attachments/assets/f3224130-9aab-4ad9-addd-361520c3f6fb)

# 데이터베이스 설계

## 데이터 모델링

데이터베이스 설계의 핵심 단계로 비즈니스 요구 사항을 데이터 모델로 변환하는 과정

이를 통해 비즈니스 요구사항을 명확히 이해하고 이를 데이터베이스 구조로 변환 가능

데이터 모델링은 데이터베이스의 각 테이블 정의, 엔티티간 관계, 데이터 속성 및 제약 조건 등을 명확히 문서화하여 전체 시스템의 이해와 협업을 쉽게 만듦

주요 단계로는 개념적, 논리적, 물리적 모델링이 있음

## 1. 개념적 데이터 모델링

![image](https://github.com/user-attachments/assets/7566782c-ae31-4449-aaab-c81a098de5c5)

데이터베이스 설계의 초기 단계로 비즈니스 요구사항을 이해하고 이를 데이터 모델로 변환하는 과정

주로 엔티티와 관계를 중심으로 진행

- 엔티티 정의: 비즈니스에서 중요한 개념이나 객체를 엔티티로 정의
- 관계 정의: 엔티티 간 관계를 정의, 관계는 일반적으로 일다일, 일대다, 다대다 등의 형태로 표현

## 2. 논리적 데이터 모델링

개념적 데이터 모델링을 기반으로 데이터베이스 시스템이 실제 구현될 때 사용될 데이터베이스 객체를 정의하는 과정

- 테이블 정의: 개념적 모델에서 정의한 엔티티를 테이블로 변환
- 테이블 간 관계 정의: 엔티티 간 관계를 테이블 간 외래키로 정의

## 3. 물리적 데이터 모델링

실제 데이터베이스 관리 시스템에 특화된 구현 단계로 논리적 모델을 특정 DBMS에서 사용할 수 있는 데이터베이스 객체로 변환하는 과정

- 테이블을 실제 데이터베이스 객체로 변환: 테이블 변환과 테이블의 각 열에 대한 데이터 유형과 제약조건 정의
- 인덱스 생성: 검색 성능 향상을 위한 인덱스를 생성하고 관리
- 데이터베이스 객체 정의: 테이블, 뷰, 인덱스, 저장 프로시저 등의 데이터베이스 객체를 정의하여 실제 데이터베이스에 구축

## 개체-관계 다이어그램(ERD)

![image](https://github.com/user-attachments/assets/a3e1cabc-db94-4036-97d4-dbf75dbb4092)

데이터 모델링에서 사용되는 개념적 도구로 엔티티, 속성, 관계를 시각적으로 표현하는 방법

주로 관계형 데이터베이스 설계에 사용

### 사용 목적

- 비즈니스 요구사항 분석: ERD를 사용하여 비즈니스 프로세스와 데이터 간 관계를 명확히 이해하고 문서화 가능
- 데이터베이스 설계: 데이터베이스 구조를 정의하고 개발자와 비즈니스 사용자 간 의사소통 촉진
- 데이터 일관성 유지: 엔티티와 속성을 명확히 정의하고 관계를 시각적으로 표현하여 데이터 일관성을 유지하고 검증
- 시스템 설계 및 개발 지원: ERD는 시스템 설계 및 개발 과정에서 데이터베이스 구조를 파악하고 구현하는데 도움

### ERD 구성 요소

- 엔티티: 현실 세계에서 독립적으로 존재하는 객체로, 데이터베이스에서는 테이블
- 속성: 엔티티의 특성이나 데이터
- 관계: 엔티티 간 연결, 데이터 흐름 정의
- 기본 키: 엔티티에서 각 행을 고유하게 식별하는 필드, 유일성 보장
- 외래 키: 다른 테이블의 기본키를 참조하는 속성, 관계를 통해 데이터 일관성 유지

## 정규화

데이터베이스 설계에서 중복을 최소화하고 데이터 일관성과 무결성을 유지하기 위해 데이터를 구조화하는 과정

주로 관계형 데이터베이스에서 사용

### 주요 목적

- 중복 제거
- 데이터 의존성 제거
- 검색 최적화
    - 단, 조인 비용이 증가할 수 있고 데이터가 여러 테이블에 분산되어 있을 경우 인덱스 효율성이 감소하여 읽기 성능 저하 가능

### 주요 단계

- 제 1 정규화 (1NF): 모든 속성 값이 원자적이어야 함, 하나의 속성이 하나의 값을 가져야 함

![image](https://github.com/user-attachments/assets/1ead71a3-eabf-42a7-9717-eb248afba102)

- 제 2 정규화 (2NF): 모든 비주요 속성이 주요 키 전체에 대해 완전 함수적 종속성을 가져야 함. 부분적 종속성 제거

![image](https://github.com/user-attachments/assets/bd0915a5-653c-4d43-8cac-4e39d92b6732)

- 제 3 정규화 (3NF): 모든 비주요 속성이 후보키에 이행적으로 종속되지 않아야 함. 이행적 종속성 제거

![image](https://github.com/user-attachments/assets/157a97e8-e667-40cb-9e38-ab3a60f9f009)

- BCNF (Boyce-Codd 정규형): 모든 결정자가 후보키여야 함. 함수적 종속성을 유지하고 분해되지 않도록 함

![image](https://github.com/user-attachments/assets/6d40ce7f-cb62-489d-b1b1-5010c920f04d)

- 제 4 정규화 (4NF): 다치 종속성을 제거하여 다중 값 종속성 분리

![image](https://github.com/user-attachments/assets/d1742444-de39-409e-93ac-4e6cfdfa7bce)

- 제 5 정규화 (5NF): 조인 종속성을 제거하여 관련 속성 분리

![image](https://github.com/user-attachments/assets/aea7c028-87ef-4e6f-b0ec-136e667d0225)

## 정규화의 장단점

정규화는 데이터의 구조를 최적화하여 효율적인 데이터베이스 운영을 가능하게 하지만 모든 경우에 정규화가 필수는 아니며 설계의 목적과 요구사항에 따라 적절한 정규화 수준을 선택해야 함

### 장점

- 데이터 일관성과 무결성 보장
- 저장 공간을 최적화하고 중복을 줄여 데이터 관리 용이

### 단점

- 더 많은 테이블이 생성되어 상능 저하 가능성
- 복잡한 쿼리 작성 필요

# 데이터베이스 백업 및 복구 전략

## 데이터베이스 백업 전략

### 백업 유형

- 전체 백업: 데이터베이스의 전체 내용 백업, 정기적으로 수행되며 기본적인 백업 데이터 세트 제공
- 차등 백업: 마지막 전체 백업 이후 변경된 데이터만 백업, 일반적으로 일일 백업 주기에서 사용되어 시간과 저장 공간 절약
- 증분 백업: 마지막 백업 이후 변경된 모든 데이터를 백업, 차등 백업보다 더 작은 데이터 집합을 처리하지만 복구 시 여러 증분 백업 파일을 필요로 할 수 있음

### 백업 주기

백언 주기는 데이터 중요성과 변경 빈도에 따라 설정됨

보통 실시간 백업은 비용이 많이 들어 일일 백업 또는 주간 백업같은 스케줄 사용

### 다중 백업 위치

재난 시나리오를 대비하여 백업 파일을 여러 물리적 위치나 클라우드 저장소에 저장

### 로그 백업

트랜잭션 로그와 같은 추가적인 데이터베이스 로그를 정기적으로 백업하여 데이터 상세 변경 이력을 기록하고 장애 발생 시 데이터베이스를 특정 시점으로 복구할 수 있게 함

## 데이터베이스 복구 전략

### 1. 복구 계획 수립

- 데이터베이스 시스템 장애 발생 시의 복구 절차를 포함한 복구 계획 작성
- 이 계획은 특정 장애 시나리오와 복구 시점을 명확히 정의하며 이를 위해 필요한 인력 및 자원 결정

### 2. 백업 활용

- 백업된 데이터를 사용하여 시스템을 복구하는 절차를 세부적으로 문서화
- 백업 파일과 로그 파일을 적절히 조합하여 데이터 일관성과 무결성 보장

### 3. 테스트 및 검증

- 정기적으로 백업 및 복구 절차를 테스트하고 검증하여 실제 장애 상황에 대비
- 이는 데이터 손실을 최소화하고 신속한 복구를 지원하기 위한 필수 단계임

### 4. 비상 대응 계획

- 예상치 못한 장애 발생 시 신속하게 대응할 수 있는 비상 대응 계획 마련
- 특정 인력의 역할과 책임을 명확히 하고 재난 복구를 위한 준비를 완료함
