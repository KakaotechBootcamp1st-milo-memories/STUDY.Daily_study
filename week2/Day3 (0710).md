# 지난 실습 피드백

## 전역 상태 관리

- 전역 상태 관리는 두 가지 경우 사용 가능
    - 모든 컴포넌트에서 필요한 데이터가 있을 때
    - props drilling 문제를 해결할 때
- useState, useReducer, useContext 등의 상태 관리 함수를 동시에 사용할 수 있고 여러 개 사용할 수 있다.

# React 아키텍쳐 패턴

## 아키텍쳐 패턴의 기본 개념

### 소프트웨어 아키텍쳐와 디자인 패턴

- 소프트웨어 아키텍쳐란 소프트웨어 시스템 구조를 정의하고 설계하는 과정
- 시스템 구성 요소 간 상호 작용 방식, 데이터 처리 방법, 사용자 인터페이스와의 상호작용 방식 등을 포함
- 아키텍쳐 패턴은 특정 문제를 해결하기 위해 반복적으로 사용할 수 있는 설계 패턴이며, 이는 소프트웨어 아키텍쳐를 구성하는 핵심 요소 중 하나
- 아키텍쳐 패턴은 공통된 설계 문제를 해결하는 방법을 제시하고 이를 통해 코드 재사용성, 유지보수성, 확장성을 향상시킴

### 단순한 프로젝트 구조의 문제점

1. 구조화와 유지보수성의 부족
    - 단일 컴포넌트 패턴만 사용하여 대규모 앱을 개발하면 모든 기능을 하나의 컴포넌트에 집어넣어 코드가 길어지고 복잡해짐
    - 각 기능을 독립적으로 테스트하거나 변경하기 어려워짐
    - UI 로직과 비즈니스 로직이 섞이면서 코드 가독성이 저하되고 유지보수가 어려워짐
2. 상태 관리의 어려움
    - 컴포넌트 간 직접적으로 상태를 전달하거나 상위 컴포넌트에서만 상태를 관리하는 경우 Props drilling이 발생하거나 관리에 어려움이 발생할 수 있다.
3. 비즈니스 로직과 UI 로직의 혼합
    - 동일 로직이 여러 컴포넌트에서 중복될 수 있고 유지보수성, 확장성이 제한될 수 있음

### 아키텍쳐 패턴의 중요성

- 코드 구조화와 모듈화
- 유지 보수성 및 확장성 향상
- 개발자 팀 간의 협업 효율성 증대

### 아키텍쳐 패턴의 종류

- 단일 컴포넌트 패턴
- 컨테이너/프레젠테이셔널 패턴
- HOC 패턴
- Flux 아키텍쳐
- 모듈형 아키텍쳐
- FSD 아키텍쳐
- 등등 …

## 주요 아키텍쳐 패턴

### 단일 컴포넌트 패턴

- 하나의 컴포넌트가 UI의 모든 부분을 담당하며 별도의 하위 컴포넌트를 사용하지 않거나 최소한의 컴포넌트만 사용함
- 문제점
    - 코드 재사용성 감소
    - 유지보수의 어려움
    - 성능 최적화 한계
    - 테스트의 어려움

### 컨테이너/프레젠테이셔널 패턴

- 컴포넌트 역할에 따라 컨테이너나 프레젠테이셔널 컴포넌트로 구분하여 관리
- 컨테이너 컴포넌트
    - 주로 상태 관리나 데이터 로직을 처리하며 API와의 통신이나 상태 관리 라이브러리와의 연결을 담당
- 프레젠테이셔널 컴포넌트
    - 주로 UI를 표시하고 사용자와의 인터랙션을 담당
    - 상위로부터 받은 props를 받아와 UI를 랜더링하며 상태나 데이터를 직접적으로 관리하지 않음

### HOC(Higher-Order Component) 패턴

- 컴포넌트 로직을 재사용하기 위한 패턴으로 고차 컴포넌트는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환
- 일반적으로 함수 이름 앞에 with를 붙여 구현
- 주요 용도
    - 상태 관리 및 로직 추가 : HOC를 사용하여 상태 관리 로직이나 라이프 사이클 메소드 등을 추가할 수 있음
    - 인증 및 권한 관리
    - 코드 재사용
- 주의 사항
    - 컴포넌트 구조의 복잡성 : 과도한 사용은 구조를 복잡하게 만듦
    - 명확한 컴포넌트 구분 : 너무 많은 로직을 한 번에 처리하지 않도록 해야함
    - 컴포넌트 트리 구조 이해 : HOC는 특정 컴포넌트의 래핑을 통해 구현되므로, 트리 구조에서 어떻게 동작하고 렌더링되는지 이해하는 것이 중요

### Flux 아키텍쳐

- 클라이언트 측 웹 앱을 구축하기 위해 설계된 앱 아키텍쳐
- 앱 내 데이터 흐름을 명확히 정의하여 상태 관리를 용이하게 함
- 데이터 흐름
    - Flux는 단방향 데이터 흐름을 따름
    - 사용자 상호작용은 View에서 Action으로 반환되고, Dispatcher를 통해 모든 Store에게 전달됨
    - 각각의 Store는 Dispatcher에 등록된 콜백을 통해 Action을 처리하고 필요에 따라 상태를 변경하며 이벤트를 발생시켜 View에게 새로운 데이터를 전달함
- 구성 요소
    - Dispatcher : 앱 내에서 모든 데이터 흐름을 중앙에서 관리, Action을 받아 등록된 모든 Stores에 전달함
    - Stores : 앱 상태와 데이터 로직을 포함, Store는 상태를 변결할 때 마다 View에게 알리는 역할을 하며 View는 데이터가 변경될 때마다 자동으로 업데이트 가능
    - Views : Stores로부터 데이터를 받아와 화면에 렌더링, 사용자의 상호작용을 Dispatcher를 통해 Action으로 변환하여 데이터 변경 요청 가능
    - Controller-Views : Stores로부터 데이터를 받아 하위 View에 전달하는 역할
        

### 모듈형 아키텍쳐

- 코드를 모듈 단위로 분리하고 구성하여 코드 재사용성, 유지보수성, 확장성을 높이는 아키텍쳐적 접근 방식
- 모듈을 독립적으로 테스트하고 배포할 수 있는 단위로 비즈니스 로직이나 기능별로 분리되어야 함
- 일종의 객체지향 프로그래밍을 위한 아키텍쳐로 볼 수 있음
- 주요 개념
    - 모듈 : 앱 내 특정 기능이나 독립적인 기능 단위
    - 단일 책임 원칙 : 각 모듈이 한 가지 기능 또는 책임을 가지도록 설계해야 함
- 주의 사항
    - 의존성 관리
    - 테스트와 배포
    - 명명 규칙
- 모듈 아키텍쳐와 OOP의 SOLID 원칙
    - 단일 책임 원칙
    - 개방-폐쇄 원칙
    - 리스코프 치환 원칙
    - 인터페이스 분리 원칙
    - 의존성 역전 원칙

### FSD 아키텍쳐

- 모듈형 아키텍쳐에서 변형한 아키텍쳐
- 슬라이스와 세그먼트 : 각 계층은 슬라이스로 나누어지며 비즈니스 도메인에 따라 코드를 파티션화
    - 슬라이스는 서로 다른 기능 영역을 유지하며 코드베이스를 쉽게 탐색할 수 있도록 함
    - 슬라이스와 함께 각 게층은 기술적인 목적에 따라 세그먼트로 구성됨

<img width="719" alt="image" src="https://github.com/KakaotechBootcamp1st-milo-memories/STUDY.Daily_study/assets/102672547/53e460a1-e5c7-402b-89b9-6c93792ed9b4">

- 주요 계층적 구조
    - APP
    - Pages
    - Widgets
    - Feature
    - Entities
    - Shared
- 슬라이스
    - FSD에서 두 번째 수준의 조직적 계층, 주된 목적은 앱 의미에 따라 코드를 그룹화하는 것
    - 슬라이스 이름은 앱 비즈니스 도메인에 따라 결정되므로 표준화되지 않음
    - 슬라이스 내부에서는 비즈니스와 연관된 로직을 작성할 수 있음
    - 슬라이스 내부에서는 여러 그룹의 세그먼트를 가질 수 있으나 특정 코드를 세그먼트로 만들지 않고 배치하지 않음
- 세그먼트
    - 조직적 계층의 세 번째이자 마지막 수준이며 코드의 기술적 특성에 따라 코드를 그룹화하는 목적을 가짐
    - 이름은 ui, model, lib, api등이 될 수 있음
    
    <img width="719" alt="image" src="https://github.com/KakaotechBootcamp1st-milo-memories/STUDY.Daily_study/assets/102672547/8a6512de-f7dc-4595-8e26-bbbfcb36d5fa">
    
- 장점
    - 일관성 유지
    - 변화와 리팩토링에 대한 안정성
    - 로직의 제어된 재사용
    - 비즈니스와 사용자 중심의 지향
    - 점진적 채택

### Controlled vs Uncontrolled Components

- 폼 관리 패턴은 사용자 입력을 다루는 부분에서 Controlled vs Uncontrolled로 나뉘어짐
- Controlled Components
    - React 컴포넌트가 입력 필드의 상태를 제어하는 방식
    - 입력 필드 값은 컴포넌트의 상태로 관리되며 사용자가 입력을 변경할 때마다 상태가 업데이트됨
    - 특징
        - 폼 요소 값은 State로 관리
        - 값이 변경될 때마다 onChange 이벤트 핸들러를 통해 상태 업데이트
    - 장점
        - 데이터 흐름이 단방향으로 명확해지므로 디버깅 용이
        - 폼 유효성 검사 및 동적 변경 용이
        - 상태를 중앙에서 관리할 수 있어 보다 일관된 상태 관리 가능
    - 단점
        - 폼 요소가 많을 경우 코드 복잡성 증가
        - 매 입력마다 상태 업데이트가 발생하여 성능에 영향을 줄 수 있음
- Uncontrolled Components
    - 폼 요소 자체가 상태를 관리하는 방식
    - React는 폼 요소 값에 직접 접근하지 않으며 필요할 때만 참조를 통해 값을 가져옴
    - 특징
        - 폼 요소 값은 컴포넌트 상태로 관리되지 않고 DOM에서 직접 관리
        - React의 ref를 사용하여 폼 요소에 접근
        - 초기 값만 React를 통해 설정되고 이후에는 폼 자체에서 값을 관리
    - 장점
        - 초기값만 설정하고 이후 관리가 필요없으므로 코드 간결
        - 폼 요소가 많은 경우 성능 상 이점
    - 단점
        - 상태 관리 유연성 저하
        - 폼 유효성 검사 및 동적 변경의 어려움
