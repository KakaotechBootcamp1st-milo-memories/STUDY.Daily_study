# 클라우드 환경의 이해

### AWS에서 정의하는 클라우드 컴퓨팅

- IT 리소스를 인터넷을 통해 온디멘드로 제공하고 사용한만큼만 비용을 지불하는 것
- 물리적인 설비를 구축하는 대신 AWS와 같은 클라우드 공급자로부터 필요에 따라 컴퓨팅 파워, 스토리지, 데이터베이스와 같은 기술 서비스에 액세스 가능

### CNCF에서 정의하는 클라우드 네이티브

- 조직이 퍼블릭, 프라이빗, 그리고 하이브리드 클라우드와 같은 현대적이고 동적인 환경에서 확장 가능한 앱을 개발하고 실행할 수 있게 해줌
- 컨테이너, 서비스 메쉬, 마이크로서비스, 불변 인프라, 선언형 API가 이런 접근 방식의 예시들임

## 클라우드를 사용하는 이유

- 유연한 확장: 리소스 사용량, 네트워크 트래픽을 기준으로 사용량에 맞게 확장, 축소 가능
- 비용 절감: 하드웨어를 직접 구매하여 인프라를 구성하는 온프레미스 환경과는 달리 사용한만큼 비용을 지불하여 비용 절감 효과가 큼
- 효율적인 관리: 인프라 유지보수를 직접하는 것이 아니라 클라우드 벤더사에서 담당하기 때문에 제품 개발에 집중 가능

## 왜 클라우드인가?

### 위험성

- 데이터 유출 및 해킹 위험에 노출
- 서비스 가용성을 오롯이 클라우드 벤더사에 의존하여 벤더사의 문제가 서비스 문제로 직결됨
- 확장이 손쉽게 이뤄지기 때문에 이를 효과적으로 관리하지 못하면 비용이 과하게 나올 수 있음

### 온프레미스 환경은 어떨 때 사용할까?

- 금융, 의료, 정부 사업 등 보안에 민감한 사업의 경우 인프라, 데이터가 물리적으로 분리되어 있어야 할 필요가 있는 경우가 있음
- 게임 산업, 금융 서비스, 군사 산업 등 지연 시간을 최소로 하는 것이 중요한 산업들에서 온프레미스 환경을 사용하는 경우가 있음
- 단점들을 보완하기 위해 하이브리드 클라우드, 멀티 클라우드 등 다양한 형태의 클라우드 사용 사례들이 생기고 있음

## CPU 아키텍쳐에 대해 꼭 알아야할까?

- 서비스 앱이 운영되는 환경은 하드웨어에서부터 다양함
    - arm, x86과 같은 CPU부터 GPU, TPU, NPU에 이르기까지 고려해야할 환경이 많다.
    - 사용 가능한 리소스 제한에 따라 개발 방향이 변경될 수 있음
        - CPU, 메모리, Storage, 성능, 네트워크 성능 등 다양한 변수 존재

### CPU 아키텍쳐란?

- 마이크로아키텍쳐로도 부르며 하드웨어가 작동하는 방식을 나타냄
- 상용화된 제품을 기준으로는 ARM(RISC)과 x86(CISC)이 대표적

## 개발자에게 운영체제란?

- 하드웨어와 소프트웨어 간의 인터페이스 제공
- 하드웨어 리소스 관리
- 파일 시스템 제공
- 네트워크 통신
- 시스템 콜
- 유렉스, 세마포어
- 페이징, 세그멘테이션
- 페이징 교체 알고리즘
- 보안
- ..
- ..

### 어디까지 알아야할까?

- 많이 알면 알수록 좋음
- 리눅스와 컨테이너 기술의 배경
- 개발자이던 시절 알았다면 좋았던 것들
    - 프로세스 관리
    - 메모리 관리
    - 파일 시스템
    - 스케줄링
    - 네트워크
    - ..

## 리눅스와 컨테이너 기술의 배경

### 리눅스의 멀티 유저 특성

- 리눅스는 본질적으로 여러 사용자가 하나의 시스템에서 동시에 작업할 수 있는 환경을 지원
- 각 사용자는 자신의 환경과 파일, 프로세스 등을 독립적으로 관리 가능

### 컨테이너 기술

- 컨테이너 기술은 이러한 리눅스의 멀티 유저를 지원하는 특성을 확장하여 프로세스, 리소스 등을 격리된 환경에서 사용할 수 있도록 제공
- 클라우드 컴퓨팅과 마이크로 서비스 아키텍쳐를 구성하는데 중요한 역할

## 개발자이던 시절 알았다면 좋았을 것들 - 운영체제

### Too many open files/최대 생성 프로세스 제공

- 보안 상 이유로 Linux 상에서 생성할 수 있는 프로세스, 프로세스가 열 수 있는 파일 수를 제한하고 있음
- 때문에 개발 과정에서 마주하게 되는 오류 중 하나
- 실제로 프로세스 생성이나 파일 접근을 동시에 다량으로 하거나 Socket을 다루는 과정에서 발생 가능(Socket의 파일로 관리되기 때문)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0ee43fab-2947-49b1-b42b-cf1eb07e56bc/c12a8d04-e675-417f-87ee-2aaa44502bed/Untitled.png)

- /etc/security/limits.conf 혹은 ulimit 명령어를 통해 제한 값을 조정 가능

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0ee43fab-2947-49b1-b42b-cf1eb07e56bc/04441bc8-622d-4aff-abbb-b42ea15d97f9/Untitled.png)

### 부모 프로세스-자식 프로세스 관리

- 필요에 따라서는 자식 프로세스를 생성할 때 부모 프로세스에 종속되지 않게 독립된 프로세스로 생성할 수 있다.
- 고아 프로세스/좀비 프로세스 문제
    - 시스템 자원이 낭비되고 있는 상태
    - 프로세스 관리 어려움
    - PID(Process ID)의 낭비
        - 시스템에서 사용할 수 있는 PID 수가 제한되어 있으므로 프로세스 생성이 불가능해질 수 있음

### OOM(Out Of Memory)

- 크게 두가지로 분류 가능
    - 메모리 누수(Memory Leak)
    - 계획된 메모리를 초과하는 요청이 오는 경우
        - (하드웨어적 제한) 32bit CPU 경우 최대 4GB, 물리적인 메모리의 한계에 달하는 경우
        - (소프트웨어적 제한) JVM이나 V8 Engine 등에서 제한하는 경우 등
- 메모리 누수 해결
    - APM(Application Performance Monitoring) 혹은 프로파일러를 활용하여 메모리 누수 지점을 찾고 분석
    - GC(Garbage Collector) 최적화
    - 미사용 자원 해제
- 계획된 메모리를 초과하는 요청이 오는 경우
    - 정답은 없음 ⇒ 설득의 영역
    - 상황에 맞는 사양을 결정해야 함
    - 어떨 때는 스펙 변경으로 또 다른 상황에서는 코드의 최적화로 해결해야 할 수 있음
    - 트레이드 오프를 고려하여 적잘한 선택을 할 수 있어야 함
