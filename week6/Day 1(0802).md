## 온프에미스와 프라이빗 클라우드의 차이
온프레미스는 실제 환경에서 서버를 핸들링
프라이빗 클라우드라고 하면 콘솔을 통해 서버를 생성할 수 있어야하고 이것을 회사 데이터 센터에 깔아서 쓰는 것, 콘솔에서 서버를 핸들링 가능

# 클라우드 네이티브란

클라우드 이점을 최대한 활용할 수 있도록 앱을 구축, 실행, 배포하는 방식
클라우드 네이티브의 목표: 변화하는 비즈니스 요구사항에 빠르게 적응할 수 있는 유연하고 가용성이 높으며 확장 가능한 소프트웨어 제공

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/bab0a701-4adc-4b22-a258-4c7faeec7e30">

유연한 변경에 용이한 개발을 해야함

## CI/CD란
지속적인 통합(CI) + 지속적인 배포(CD)
코드 변경 사항이 자동으로 빌드, 테스트, 통합되어 서비스 환경에 배포되는 과정이 자동화된 개발 방식

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/577fc9d4-c1e6-4e9d-90ea-abef687c5dad">

테스트 커버리지가 높아질수록 CI/CD 비용이 늘어남 -> 80%를 커버하는데 50시간이 걸린다면 99%를 커버하는데는 500시간이 걸릴 수 있음
-> 트레이드 오프를 잘 해야하고 80%안에 크리티컬한 테스트가 있으면 됨

### CI: 빌드/테스트/통합의 자동화

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/b6483bf3-2cda-44d8-ba74-ddafde8c5192">

코드 변경이 적은건 스몰 라벨, 큰 것은 라지 라벨이 붙기 때문에 그에 따른 코드 리뷰 전략을 세움

### CD: 배포의 자동화

## DevOps란
소프트웨어 개발(Dev)과 운영(Ops)를 유기적으로 통합하여 개발 라이프사이클을 단축하는 동시에 비즈니스 목표를 달성할 수 있도록 빈번한 업데이트를 제공하는 것을 목표로 하는 소프트웨어 엔지니어링 문화
규모가 큰 회사에서는 개발팀과 운영팀이 나눠지고 이 팀들이 빠르게 소통할 수 있는 구조를 만들어 개발 라이프 사이클을 빠르게 돌 수 있게 만들어야 함

### DevOps의 핵심 원칙
#### 협업 및 커뮤니케이션
개발, 테스터, 운영 팀 간 정기적 커뮤니케이션과 조정을 통해 모든 사람이 변경 사항, 위험 및 개선 기회 인지, 부서 간 사일로를 허물고 응집력 있는 팀으로 협력하여 소프트웨어 업데이트를 빠르고 효율적으로 제공
#### 자동화
예를 들어 코드 빌드 및 테스트, 앱 배포, 인프라 관리와 같은 작업 자동화
자동화를 통해 소프트웨어 업데이트를 더 빠르고 높은 품질로 제공
가능한 많은 작업을 자동화하여 효율성 개선, 인적 오류 감소, 일관된 결과를 보장하여 프로세스 속도를 높이는 것
#### 지속적인 개선 및 낭비 최소화
데이터와 피드백을 사용하여 프로세스와 시스템을 지속적으로 평가하고 효율성 개선
#### 짧은 피드백 루프를 통해 사용자화 우선

## 마이크로서비스 아키텍쳐란(MSA)란
대규모 앱이 API를 통해 서로 통신하는 작고 독립적인 서비스 모음으로 구성되는 소프트웨어 아키텍쳐
진정한 MSA의 효과를 누릴려면 DB까지 나눠야함. -> DB를 하나로 사용하면 부서 별로 DB를 마음대로 바꾸지 못함.
모놀리틱 아키텍쳐가 무조건 나쁜건 아님. -> 모놀리틱과 마이크로서비스는 대비되는 아키텍쳐일 뿐임 -> 요구 사항과 개발 상황에 따라 적절히 선택하면 됨
<img width="1047" alt="image" src="https://github.com/user-attachments/assets/86fbbe6c-d31a-44b6-a796-3a1898cbf08d">

한 모듈을 변경할 때 다른 모듈들도 추가 테스트가 필요함
모듈이 자주 변경되고 각 모듈의 테스트가 된다해도 전체 통합 테스트의 실행이 보장되지 않음
한 모듈의 Heat가 커져도 전체 앱을 Scale해야함
한 모듈에서 오류가 발생하면 서비스 전체에 에러가 생김
<img width="1047" alt="image" src="https://github.com/user-attachments/assets/e1883ce9-5a95-4253-88e5-530c1bb8cc0b">

앱이 커지면 복잡해지지만 쪼개서 보면 그렇게 크지 않음
오류 발생 시 어떤 부분을 봐야할지 찾기가 쉬움
전체 아키텍쳐를 몰라도 자신 담당의 모듈만 관리할 수 있음
하지만 분산된 수백, 수천 개의 작은 앱을 관리해야하며 앱 별 다양한 런타임 환경, 성능 간섭이 발생
잦은 빌드/배포, 설정 관리가 복잡하며 트래픽 분산 관리, 서비스 디스커버리 등 필요
여러 개발 환경 사용 시 서버가 무거워짐
유저 트래픽 발생 시 트래픽 분산관리, 로드 밸런싱을 해줘야 함

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/cba24f6c-99b7-4470-9d2e-d2e3eb7a0d02">

## 컨테이너란?

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/cc33a1c7-a369-4308-8e81-755fab7ea8c0">

컨테이너는 실행 환경과 성능을 격리, 표준화

앱을 OS 환경까지 가상화해서 패키징
컨테이너는 OS 환경까지 패키징되어 Linux, Windows, Mac, 가상 머신, 베어메탈, 개발자의 컴퓨터, 데이터 센터, 온프레미스 환경, 퍼블릭 클라우드 등 어느 환경에서나 구동되므로 개발 및 배포가 쉬워짐

앱의 성능 격리
컨테이너는 CPU, 메모리, 스토리지, 네트워크 리소스를 OS 수준에서 가상화하여 개발자에게 기타 앱으로부터 논리적으로 격리된 OS 샌드박스 환경 제공

도커(docker)
컨테이너를 실행시키거나 컨테이너 이미지로 빌드하는 과정에서 많이 사용하는 컨테이너 관리 도구

### 마이크로서비스의 단점을 극복하는 기술: 컨테이너와 쿠버네티스
- 다양한 앱 환경을 OS까지 이미지화 배포, 성능 격리
- Container Orchestration: 사실상의 표준 Kubernetes
- 앱에서 행이 거린 것을 감지하지 못하기 때문에 헬스 체크 포인트를 지정해줘야 함 -> 밤에 서비스가 죽어도 자동으로 관리해주기 때문에 계속 자도 됨

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/0620edc4-6248-4979-af00-61921e6a7278">

#### 마이크로서비스의 복잡성을 클라우드 환경에서 해결
이전에도 비슷한 기술을 있었음
before cloud : 마이크로 서비스를 구현하기 위한 인프라를 앱에서 전부 구현
after cloud: 비즈니스 로직을 제외한 인프라 역할은 클라우드로 이관

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/c9fccae8-5f60-478e-a28f-4b3bc315b976">

## VM과 컨테이너의 차이

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/900759fb-3cae-4a01-8ccf-e537b72d0e5b">

### VM
VM은 물리 서버가 있고 OS 깔고 KVM 하이퍼바이저를 깔아서 VM은 띄움
VM은 게스트 이미지로 런할 때 커널부터 부팅하여 가상의 머신을 에뮬레이션하여 올림
서버를 하이퍼바이저를 통해서 CPU와 메모리를 할당받아서 사용함
장점은 커널 위에서 커널을 또 띄우는 것이다 보니 별도의 커널에서 에러가 나도 독립적임, 호스트 커널 죽으면 다 죽음
단점은 물리 머신을 에뮬레이션하여 띄우다 보니 부팅 시간과 작업 시간이 느림

### 컨테이너
컨테이너는 격리된 프로세스를 띄우는 것 -> 성능 병목이 거의 없음
물리 서버에서 직접 동작시키는 것과 성능 차이가 거의 없음
커널위에서 별도의 프로세스를 띄우는 것
여기도 호스트 커널 죽으면 다 죽음
앱 간의 도커 브릿지를 통해 앱의 통신이 가능
쿠버네티스를 사용할 때는 로컬 호스트로 통신하면 됨
컨테이너만 있다면 어디서든 OS를 가리지 않고 실행 가능
### -> 컨테이너는 '하드웨어'를 '소프트웨어'로 구현한 가상 머신이 아니라 격리된 환경에서 실행된 프로세스임
운영 체제 관점에서 보면 컨테이너 이미지 = 실행 파일 / 컨테이너 = 프로세스
단지 실행되는 root path와 리소스, 권한이 격리되어 있음

<img width="557" alt="image" src="https://github.com/user-attachments/assets/f1891899-1d97-4bf5-b424-00fe69bb6aca">

#### 파일 시스템의 가상화/격리

<img width="1027" alt="image" src="https://github.com/user-attachments/assets/3c55bb25-7d5f-4a82-bf2a-9d7c43794680">

<img width="1036" alt="image" src="https://github.com/user-attachments/assets/ad0e006f-5ee3-4692-94b8-be9fc687f5f4">

<img width="829" alt="image" src="https://github.com/user-attachments/assets/6c67a2bf-dd12-47cb-88d0-1a4b53790507">

#### 실습 주소 : [https://dennis.k8s.kr/2](https://dennis.k8s.kr/2)

## 실습

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/6f5ef036-7ae3-4afe-86cb-462715977608">

<img width="1098" alt="image" src="https://github.com/user-attachments/assets/7268723b-f5ce-4ce9-b3b9-5f986a11b3bd">

<img width="1098" alt="image" src="https://github.com/user-attachments/assets/91a72c9e-0b3e-43d3-9888-0c09eca801e5">

<img width="1098" alt="image" src="https://github.com/user-attachments/assets/d45fbcad-45c9-4d38-aa79-a24ad9e6927f">

<img width="1098" alt="image" src="https://github.com/user-attachments/assets/197ad059-c682-4885-8b67-97bd72e499c3">

## LXC(Linux Container


## 현대 비즈니스 환경에서 살아남기 위한 경쟁력 -> 클라우드 네이티브
최근 핫한 AI 기술을 자사 서비스에 빠르게 도입해야하는 회사의 개발자라고 가정한다면
1. 만약 MSA 구조가 아니라 거대한 모놀리틱 구조라면,
2. 컨테이너화되어 클라우드 환경에 올라가있지 않고 물리 서버 OS에 모두 직접 설치되어 있다면,
3. CI/CD 파이프라인이 자동화되어있지 않고 빌드, 테스트, 배포 과정이 모두 수작업으로 이뤄진다면,
4. 개발, 운영, 테스트 조직이 서로 소통하지 않는다면,


## 비즈니스 요구 사항과 소프트웨어 개발 방법론 진화
1. 복잡하고 불확실한 비즈니스 환경과 시장 니즈
- 뭐가 답인지 모르기 때문에 작게 만들어서 빠르게 출시하고 시장 반응을 보고 적절히 맞춰감 -> 애자일
- 사용자들도 본인의 니즈를 잘 모름 -> 써봐야 앎
- 1년을 개발해서 망하면 1년치를 다 날리는 것 -> 스프린트를 짧게 끊어 개발

<img width="1047" alt="image" src="https://github.com/user-attachments/assets/85e33b09-023c-458d-8208-bd60ec7cb9d4">

# 컨테이너 안에 로그를 쌓지마라.
도커에서 제공하는 로그 핸들러를 사용해서 스탠다드 아웃으로 뿌리면 파일로 자동으로 쌓아줌
부득이하게 로그를 파일로 쌓아야한다면 볼륨을 마운트해서 안에 쌓아야 함

### -> 빠른 릴리즈와 유연한 변경 필요

### 만약 자동차를 생각하고 진입한 사용자가 보드 단계의 서비스를 보고 실망하는 경우는 어떻게 할지..
MVP 수준을 적절하게 맞춰야 함
안정성에 덜 민감하고 트렌드에 맞춘 것을 먼저 배포하고 클로즈 베타를 해보거나
